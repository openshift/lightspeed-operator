# Helper tool to update the bundle artifacts
# Pre-requisites: opm, make, yq, operator-sdk
# Usage: ./hack/update_bundle.sh

#!/bin/bash

set -euo pipefail

TEMP_BUNDLE_CONTAINER_FILE=$(mktemp)
cleanup() {
  # remove temporary bundle container file
  if [ -n "${TEMP_BUNDLE_CONTAINER_FILE}" ]; then
    rm -f "${TEMP_BUNDLE_CONTAINER_FILE}"
  fi

}

trap cleanup EXIT

SCRIPT_DIR=$(dirname "$0")

usage() {
  echo "Usage: $0 [-v bundle_version] [-h]"
  echo "  -v bundle_version: The version of the bundle"
  echo "  -i related_images_filename: The JSON file containing the related images"

  echo "  -h: Show this help message"
}

BUNDLE_VERSION=""
RELATED_IMAGES_FILENAME=""
CHANNEL_NAME="alpha"

while getopts ":v:i:h" opt; do
  case "$opt" in
  "v")
    BUNDLE_VERSION=${OPTARG}
    echo "bundle_version is ${BUNDLE_VERSION}"
    ;;
  "i")
    RELATED_IMAGES_FILENAME=${OPTARG}
    if [ ! -f "${RELATED_IMAGES_FILENAME}" ]; then
      echo "related_images_filename ${RELATED_IMAGES_FILENAME} does not exist"
      exit 1
    fi
    echo "related_images from file ${RELATED_IMAGES_FILENAME}"
    ;;
  "c")
    CHANNEL_NAME=${OPTARG}
    echo "channel_name is ${CHANNEL_NAME}"
    ;;
  "h")
    usage
    exit 0
    ;;
  "?")
    echo "Unknown option $OPTARG"
    usage
    exit 1
    ;;
  *)
    echo "Unknown error while processing options"
    exit 1
    ;;
  esac
done

if [ -z "${BUNDLE_VERSION}" ]; then
  echo "bundle_version is required"
  usage
  exit 1
fi

# default flag for bundle generation
: ${BUNDLE_GEN_FLAGS="--channels=${CHANNEL_NAME} --default-channel=${CHANNEL_NAME} -q --overwrite --version ${BUNDLE_VERSION}"}
BUNDLE_GEN_FLAGS="${BUNDLE_GEN_FLAGS} --version ${BUNDLE_VERSION}"

# Tool check
: ${YQ:=$(command -v yq)}
echo "using yq from ${YQ}"
if [ -z "${YQ}" ]; then
  echo "yq is required"
  exit 1
fi

: ${JQ:=$(command -v jq)}
echo "using jq from ${JQ}"
if [ -z "${JQ}" ]; then
  echo "jq is required"
  exit 1
fi

: ${OPERATOR_SDK:=$(command -v operator-sdk)}
echo "using operator-sdk from ${OPERATOR_SDK}"
if [ -z "${OPERATOR_SDK}" ]; then
  echo "operator-sdk is required"
  exit 1
fi

: ${KUSTOMIZE:=$(command -v kustomize)}
echo "using kustomize from ${KUSTOMIZE}"
if [ -z "${KUSTOMIZE}" ]; then
  echo "kustomize is required"
  exit 1
fi

CSV_FILE="bundle/manifests/lightspeed-operator.clusterserviceversion.yaml"
ANNOTATION_FILE="bundle/metadata/annotations.yaml"

BUNDLE_DOCKERFILE="bundle.Dockerfile"

# related_images.json is the single source of truth for (component_name, image) pairs.
# When -i is not provided, fall back to existing CSV so make bundle without -i still works.
if [ -f "${RELATED_IMAGES_FILENAME}" ]; then
  echo "using related images from file ${RELATED_IMAGES_FILENAME}"
  RELATED_IMAGES=$(${JQ} '.' ${RELATED_IMAGES_FILENAME})
else
  echo "error: provide -i related_images.json or run from a tree with an existing bundle CSV"
  exit 1
fi

if [ -z "${RELATED_IMAGES}" ] || [ "${RELATED_IMAGES}" = "null" ]; then
  echo "RELATED_IMAGES is empty, please provide related images via -i related_images.json"
  exit 1
fi

# For CSV deployment substitution we use hack/image_placeholders.json (placeholders must match config/default/kustomization.yaml).
OPERATOR_IMAGE=$(${JQ} -r '.[] | select(.name == "lightspeed-operator") | .image' <<<"${RELATED_IMAGES}")
echo "Updating bundle artifacts for image ${OPERATOR_IMAGE:-<from related_images>}"
rm -rf ./bundle

${OPERATOR_SDK} generate kustomize manifests -q
${KUSTOMIZE} build config/manifests | ${OPERATOR_SDK} generate bundle ${BUNDLE_GEN_FLAGS}
# replace the bundle.Dockerfile generated by operator-sdk with our version
cp ./hack/${BUNDLE_DOCKERFILE} .
${OPERATOR_SDK} bundle validate ./bundle

# Substitute deployment args and container image from related_images.json using placeholder map.
PLACEHOLDERS_FILE="${SCRIPT_DIR}/image_placeholders.json"
if [ ! -f "${PLACEHOLDERS_FILE}" ]; then
  echo "error: ${PLACEHOLDERS_FILE} not found"
  exit 1
fi
PLACEHOLDERS=$(${JQ} '.' "${PLACEHOLDERS_FILE}")
${JQ} -c '.[]' <<<"${PLACEHOLDERS}" | while IFS= read -r entry; do
  NAME=$(${JQ} -r '.name' <<<"${entry}")
  PLACEHOLDER=$(${JQ} -r '.placeholder' <<<"${entry}")
  TARGET=$(${JQ} -r '.target' <<<"${entry}")
  IMG=$(${JQ} -r --arg n "${NAME}" '.[] | select(.name==$n) | .image' <<<"${RELATED_IMAGES}")
  [ -z "${IMG}" ] || [ "${IMG}" = "null" ] && continue
  # Escape double quotes for use inside yq double-quoted string
  IMG_SAFE=$(printf '%s' "${IMG}" | sed 's/"/\\"/g')
  if [ "${TARGET}" = "image" ]; then
    ${YQ} "(.spec.install.spec.deployments[].spec.template.spec.containers[].image |= sub(\"${PLACEHOLDER}\", \"${IMG_SAFE}\"))" -i ${CSV_FILE}
  else
    ${YQ} "(.spec.install.spec.deployments[].spec.template.spec.containers[].args[] |= sub(\"${PLACEHOLDER}\", \"${IMG_SAFE}\"))" -i ${CSV_FILE}
  fi
done

# Set spec.relatedImages from related_images.json (strip revision for CSV if present).
RELATED_IMAGES_CSV=$(${JQ} 'map(del(.revision))' <<<"${RELATED_IMAGES}")
# set related images to the CSV file
${YQ} eval -i '.spec.relatedImages='"${RELATED_IMAGES_CSV}" ${CSV_FILE}
# add compatibility labels to the annotations file
${YQ} eval -i '.annotations."com.redhat.openshift.versions"="v4.16-v4.21"' ${ANNOTATION_FILE}
${YQ} eval -i '(.annotations."com.redhat.openshift.versions" | key) head_comment="OCP compatibility labels"' ${ANNOTATION_FILE}
${YQ} eval -i '.annotations."features.operators.openshift.io/fips-compliant"="true"' ${ANNOTATION_FILE}

echo "Finished running $(basename "$0")"
